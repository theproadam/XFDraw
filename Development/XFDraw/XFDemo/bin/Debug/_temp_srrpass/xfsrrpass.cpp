//Autogenerated by XFDraw shader parser
#include "xfcore.h"

#include "xfconfig.cpp"




inline void shaderMethod(vec3* norm_data, vec3* frag_pos, byte4* FragColor, sampler2D colorBuffer, sampler2D depthBuffer, samplerCube skybox, float ray_max_length, int ray_count, float ray_count_inverse, float ray_min_distance, GLMatrix projection, float bias){
	if ((*norm_data).x == 0 && (*norm_data).y == 0 && (*norm_data).z == 0)return;
	vec3 I = normalize((*frag_pos));
	vec3 R = reflect(I, (*norm_data));
	if (R.z <= 0){
	(*FragColor) = byte4(0, 0, 0);
	return;
	}
	int rayMax = (int)ray_max_length;
	if (rayMax <= 0) rayMax = 1;
	vec3 pos = (*frag_pos) + R * ray_min_distance;
	vec3 pos2 = pos + R;
	vec3 screen_coord = projection * pos;
	vec3 screen_coord2 = projection * pos2;
	pos.z = 1.0f / pos.z;
	pos2.z = 1.0f / pos2.z;
	float deltaX = (screen_coord2.x - screen_coord.x);
	float deltaY = (screen_coord2.y - screen_coord.y);
	if (deltaX * deltaX > deltaY * deltaY){
	float slopeZ = (pos2.z - pos.z) / deltaX;
	float bZ = -slopeZ * screen_coord.x + pos.z;
	float slope = deltaY / deltaX;
	float b = -slope * screen_coord.x + screen_coord.y;
	if (screen_coord2.x > screen_coord.x){
	for (int i = screen_coord.x;
	 i < screen_coord.x + ray_count;
	 i += rayMax){
	int2 sample_coord = int2(i, i * slope + b);
	if (sample_coord.X >= 1600 || sample_coord.Y >= 900 || sample_coord.X < 0 || sample_coord.Y < 0){
	(*FragColor) = byte4(255, 0, 255);
	return;
	}
	byte4 depth4 = textureNEAREST(depthBuffer, sample_coord);
	float depth = projection.farZ - *(float*)&depth4;
	float z_interpol = 1.0f / (i * slopeZ + bZ);
	if (abs(depth - z_interpol) <= bias){
	(*FragColor) = textureNEAREST(colorBuffer, sample_coord);
	return;
	}
	}
	}
	else{
	for (int i = screen_coord2.x;
	 i < screen_coord2.x + ray_count;
	 i += rayMax){
	int2 sample_coord = int2(i, i * slope + b);
	if (sample_coord.X >= 1600 || sample_coord.Y >= 900 || sample_coord.X < 0 || sample_coord.Y < 0){
	(*FragColor) = byte4(255, 0, 255);
	return;
	}
	byte4 depth4 = textureNEAREST(depthBuffer, sample_coord);
	float depth = projection.farZ - *(float*)&depth4;
	float z_interpol = 1.0f / (i * slopeZ + bZ);
	if (abs(depth - z_interpol) <= bias){
	(*FragColor) = textureNEAREST(colorBuffer, sample_coord);
	return;
	}
	}
	}
	}
	else{
	float slopeZ = (pos2.z - pos.z) / deltaY;
	float bZ = -slopeZ * screen_coord.y + pos.z;
	float slope = deltaX / deltaY;
	float b = -slope * screen_coord.y + screen_coord.x;
	if (screen_coord2.y > screen_coord.y){
	for (int i = screen_coord.y;
	 i < screen_coord.y + ray_count;
	 i += rayMax){
	int2 sample_coord = int2(i * slope + b, i);
	if (sample_coord.X >= 1600 || sample_coord.Y >= 900 || sample_coord.X < 0 || sample_coord.Y < 0){
	(*FragColor) = byte4(255, 0, 255);
	return;
	}
	byte4 depth4 = textureNEAREST(depthBuffer, sample_coord);
	float depth = projection.farZ - *(float*)&depth4;
	float z_interpol = 1.0f / (i * slopeZ + bZ);
	if (abs(depth - z_interpol) <= bias){
	(*FragColor) = textureNEAREST(colorBuffer, sample_coord);
	return;
	}
	}
	}
	else{
	for (int i = screen_coord2.y;
	 i < screen_coord2.y + ray_count;
	 i += rayMax){
	int2 sample_coord = int2(i * slope + b, i);
	if (sample_coord.X >= 1600 || sample_coord.Y >= 900 || sample_coord.X < 0 || sample_coord.Y < 0){
	(*FragColor) = byte4(255, 0, 255);
	return;
	}
	byte4 depth4 = textureNEAREST(depthBuffer, sample_coord);
	float depth = projection.farZ - *(float*)&depth4;
	float z_interpol = 1.0f / (i * slopeZ + bZ);
	if (abs(depth - z_interpol) <= bias){
	(*FragColor) = textureNEAREST(colorBuffer, sample_coord);
	return;
	}
	}
	}
	}
	(*FragColor) = byte4(255, 255, 255);
	
}
extern "C" __declspec(dllexport) void ShaderCallFunction(long Width, long Height, unsigned char** ptrPtrs, void* UniformPointer){
	sampler2D uniform_0;
	fcpy((char*)(&uniform_0), (char*)UniformPointer + 0, 24);
	sampler2D uniform_1;
	fcpy((char*)(&uniform_1), (char*)UniformPointer + 24, 24);
	samplerCube uniform_2;
	fcpy((char*)(&uniform_2), (char*)UniformPointer + 48, 44);
	float uniform_3;
	fcpy((char*)(&uniform_3), (char*)UniformPointer + 92, 4);
	int uniform_4;
	fcpy((char*)(&uniform_4), (char*)UniformPointer + 96, 4);
	float uniform_5;
	fcpy((char*)(&uniform_5), (char*)UniformPointer + 100, 4);
	float uniform_6;
	fcpy((char*)(&uniform_6), (char*)UniformPointer + 104, 4);
	GLMatrix uniform_7;
	fcpy((char*)(&uniform_7), (char*)UniformPointer + 108, 56);
	float uniform_8;
	fcpy((char*)(&uniform_8), (char*)UniformPointer + 164, 4);

#pragma omp parallel for
	for (int h = 0; h < Height; ++h){
		int wPos = Width * h;
		vec3* ptr_0 = (vec3*)(ptrPtrs[0] + wPos * 12);

		vec3* ptr_1 = (vec3*)(ptrPtrs[1] + wPos * 12);

		byte4* ptr_2 = (byte4*)(ptrPtrs[2] + wPos * 4);

		for (int w = 0; w < Width; ++w, ++ptr_0, ++ptr_1, ++ptr_2){
			shaderMethod(ptr_0, ptr_1, ptr_2, uniform_0, uniform_1, uniform_2, uniform_3, uniform_4, uniform_5, uniform_6, uniform_7, uniform_8);
		}
	}
}
