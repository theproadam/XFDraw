//Autogenerated by XFDraw shader parser
#include "xfcore.h"

#include "xfconfig.cpp"




inline void shaderMethod(vec3* frag_pos, vec3* normal, float* ssao_buffer, vec3 cameraPos, mat3 cameraRot, GLMatrix cameraProj, float kernel_radius, int kernel_size, sampler1D kernel, sampler2D depth, float bias, float ssao_power, int FrameCount, vec3 gl_FragCoord){
	int offset = (int)gl_FragCoord.y % 2 == 0 ? 1 : 0;
	int offsetX = FrameCount;
	if ((int)(gl_FragCoord.x + offset + FrameCount) % 2 == 0)return;
	vec3 camSpace = cameraRot * ((*frag_pos) - cameraPos);
	float occlusion = 0.0f;
	for (int i = 0;
	 i < kernel_size;
	 i++){
	vec3 pos = vec3(texture(kernel, i * 3 + 0), texture(kernel, i * 3 + 1), texture(kernel, i * 3 + 2));
	vec3 samplePos = cameraProj * (camSpace + pos * kernel_radius);
	float sampleDepth = cameraProj.farZ - texture<float>(depth, vec2(samplePos));
	occlusion += (sampleDepth >= samplePos.z + bias ? 1.0f : 0.0f);
	}
	occlusion /= kernel_size;
	occlusion *= ssao_power;
	if (occlusion > 1.0f){
	occlusion = 1.0f;
	}
	if (occlusion < 0){
	occlusion = 0;
	}
	(*ssao_buffer) = 1.0f - occlusion;
	
}
extern "C" __declspec(dllexport) void ShaderCallFunction(long Width, long Height, unsigned char** ptrPtrs, void* UniformPointer){
	vec3 uniform_0;
	fcpy((char*)(&uniform_0), (char*)UniformPointer + 0, 12);
	mat3 uniform_1;
	fcpy((char*)(&uniform_1), (char*)UniformPointer + 12, 36);
	GLMatrix uniform_2;
	fcpy((char*)(&uniform_2), (char*)UniformPointer + 48, 56);
	float uniform_3;
	fcpy((char*)(&uniform_3), (char*)UniformPointer + 104, 4);
	int uniform_4;
	fcpy((char*)(&uniform_4), (char*)UniformPointer + 108, 4);
	sampler1D uniform_5;
	fcpy((char*)(&uniform_5), (char*)UniformPointer + 112, 12);
	sampler2D uniform_6;
	fcpy((char*)(&uniform_6), (char*)UniformPointer + 124, 28);
	float uniform_7;
	fcpy((char*)(&uniform_7), (char*)UniformPointer + 152, 4);
	float uniform_8;
	fcpy((char*)(&uniform_8), (char*)UniformPointer + 156, 4);
	int uniform_9;
	fcpy((char*)(&uniform_9), (char*)UniformPointer + 160, 4);

#pragma omp parallel for
	for (int h = 0; h < Height; ++h){
		int wPos = Width * h;
		vec3* ptr_0 = (vec3*)(ptrPtrs[0] + wPos * 12);

		vec3* ptr_1 = (vec3*)(ptrPtrs[1] + wPos * 12);

		float* ptr_2 = (float*)(ptrPtrs[2] + wPos * 4);

		vec3 gl_FragCoord = vec3(0, h, 0);
		for (int w = 0; w < Width; ++w, ++ptr_0, ++ptr_1, ++ptr_2, ++gl_FragCoord.x){
			shaderMethod(ptr_0, ptr_1, ptr_2, uniform_0, uniform_1, uniform_2, uniform_3, uniform_4, uniform_5, uniform_6, uniform_7, uniform_8, uniform_9, gl_FragCoord);
		}
	}
}
