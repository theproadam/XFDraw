//Autogenerated by XFDraw shader parser
#include "xfcore.h"

#include <stdio.h>

#include "xfconfig.cpp"

inline float powf(float value, int count);
inline float max(float a, float b);
inline byte4 textureNEARESTTest(samplerCube inputCubemap, vec3 dir);


inline float powf(float value, int count){
	if (count == 0) return 1.0f;
	else if (count == 1) return value;
	else if (count == 2) return value * value;
	else if (count == 4){
	float v1 = value * value;
	return v1 * v1;
	}
	else if (count == 8){
	float v1 = value * value;
	v1 *= v1;
	return v1 * v1;
	}
	else if (count == 16){
	float v1 = value * value;
	v1 *= v1;
	v1 *= v1;
	return v1 * v1;
	}
	else if (count == 32){
	float v1 = value * value;
	v1 *= v1;
	v1 *= v1;
	v1 *= v1;
	return v1 * v1;
	}
	else if (count == 64){
	float v1 = value * value;
	v1 *= v1;
	v1 *= v1;
	v1 *= v1;
	v1 *= v1;
	return v1 * v1;
	}
	else if (count == 128){
	float v1 = value * value;
	v1 *= v1;
	v1 *= v1;
	v1 *= v1;
	v1 *= v1;
	v1 *= v1;
	return v1 * v1;
	}
	else return 1.0f;
	
}
inline float max(float a, float b){
	if (a < b) return b;
	else return a;
	
}
inline byte4 textureNEARESTTest(samplerCube inputCubemap, vec3 dir){
	int face;
	vec2 uv = Cubemap_UVFace(dir, face);
	if (face == 1) {
	face = 0;
	}
	else if (face == 0) {
	face = 1;
	}
	uv.x = 1.0f - uv.x;
	if (uv.x > 1) uv.x = 1;
	else if (uv.x < 0) uv.x = 0;
	if (uv.y > 1) uv.y = 1;
	else if (uv.y < 0) uv.y = 0;
	int X = uv.x * (inputCubemap.width - 1);
	int Y = uv.y * (inputCubemap.height - 1);
	if (face == 0){
	return inputCubemap.right[X + Y * inputCubemap.width];
	}
	else if (face == 1){
	return inputCubemap.left[X + Y * inputCubemap.width];
	}
	else if (face == 2){
	return inputCubemap.top[X + Y * inputCubemap.width];
	}
	else if (face == 3){
	return inputCubemap.bottom[X + Y * inputCubemap.width];
	}
	else if (face == 4){
	return inputCubemap.front[X + Y * inputCubemap.width];
	}
	else if (face == 5){
	return inputCubemap.back[X + Y * inputCubemap.width];
	}
	
}

inline void shaderMethod(vec3* pos, vec3* norm, byte4* objectColor, float* ssao, float* spec_power, int* reflection_index, byte4* FragColor, vec3 lightDir, sampler2D shadowMap, GLMatrix shadowProj, mat3 shadowRot, vec3 shadowPos, vec3 viewPos, float shadowBias, samplerCube reflect1, samplerCube reflect2, samplerCube reflect3, samplerCube reflect4, vec3 gl_FragCoord){
	if (*((int*)&((*objectColor))) == 0)return;
	float slope = 3.375f;
	float b = -slope * gl_FragCoord.x + gl_FragCoord.y;
	float x_intercept = -b / slope;
	const float ambientStrength = 0.2f;
	float specularStrength = (*spec_power);
	vec3 lightColor = vec3(0.8f, 0.8f, 0.8f);
	vec3 ambient = lightColor * ambientStrength;
	float diff = max(dot((*norm), lightDir), 0.0);
	vec3 objColr = vec3((*objectColor).R, (*objectColor).G, (*objectColor).B) * 0.00392156862745f;
	if ((*reflection_index) != 0){
	byte4 result;
	vec3 I = ((*pos) - viewPos);
	vec3 R = reflect(I, (*norm));
	if ((*reflection_index) == 1){
	result = textureNEARESTTest(reflect1, R);
	}
	else if ((*reflection_index) == 2){
	result = textureNEARESTTest(reflect2, R);
	}
	else if ((*reflection_index) == 3){
	result = textureNEARESTTest(reflect3, R);
	}
	else{
	result = textureNEARESTTest(reflect4, R);
	}
	if (false)if (x_intercept > 1066 && x_intercept <= 1333){
	(*FragColor) = result;
	return;
	}
	objColr = objColr * (1.0f - specularStrength) + result.xyz() * specularStrength;
	}
	if (false)if (x_intercept > 1066 && x_intercept <= 1333){
	return;
	}
	float shadowResult = 1.0f;
	if (diff != 0){
	vec3 uv = shadowProj * (shadowRot * ((*pos) - shadowPos));
	float src = shadowProj.farZ - textureNEAREST<float>(shadowMap, int2(uv.x, uv.y));
	if (uv.z > src + shadowBias){
	shadowResult = 0.0f;
	}
	}
	vec3 diffuse = lightColor * diff;
	vec3 viewDir = normalize(viewPos - (*pos));
	float spec = 0;
	if (false){
	vec3 halfwayDir = normalize(lightDir + viewDir);
	spec = powf(max(dot((*norm), halfwayDir), 0.0f), 32);
	}
	else{
	vec3 reflectDir = reflect(-lightDir, (*norm));
	spec = powf(max(dot(viewDir, reflectDir), 0.0f), 32);
	}
	vec3 specular = lightColor * specularStrength * spec;
	vec3 result = objColr * (ambient + ((diffuse + specular) * shadowResult)) * (1.0f - (*ssao)) * 255.0f;
	if (result.x > 255) result.x = 255;
	if (result.y > 255) result.y = 255;
	if (result.z > 255) result.z = 255;
	(*FragColor) = byte4(result.x, result.y, result.z);
	
}
extern "C" __declspec(dllexport) void ShaderCallFunction(long Width, long Height, unsigned char** ptrPtrs, void* UniformPointer){
	vec3 uniform_0;
	fcpy((char*)(&uniform_0), (char*)UniformPointer + 0, 12);
	sampler2D uniform_1;
	fcpy((char*)(&uniform_1), (char*)UniformPointer + 12, 28);
	GLMatrix uniform_2;
	fcpy((char*)(&uniform_2), (char*)UniformPointer + 40, 56);
	mat3 uniform_3;
	fcpy((char*)(&uniform_3), (char*)UniformPointer + 96, 36);
	vec3 uniform_4;
	fcpy((char*)(&uniform_4), (char*)UniformPointer + 132, 12);
	vec3 uniform_5;
	fcpy((char*)(&uniform_5), (char*)UniformPointer + 144, 12);
	float uniform_6;
	fcpy((char*)(&uniform_6), (char*)UniformPointer + 156, 4);
	samplerCube uniform_7;
	fcpy((char*)(&uniform_7), (char*)UniformPointer + 160, 44);
	samplerCube uniform_8;
	fcpy((char*)(&uniform_8), (char*)UniformPointer + 204, 44);
	samplerCube uniform_9;
	fcpy((char*)(&uniform_9), (char*)UniformPointer + 248, 44);
	samplerCube uniform_10;
	fcpy((char*)(&uniform_10), (char*)UniformPointer + 292, 44);

#pragma omp parallel for
	for (int h = 0; h < Height; ++h){
		int wPos = Width * h;
		vec3* ptr_0 = (vec3*)(ptrPtrs[0] + wPos * 12);

		vec3* ptr_1 = (vec3*)(ptrPtrs[1] + wPos * 12);

		byte4* ptr_2 = (byte4*)(ptrPtrs[2] + wPos * 4);

		float* ptr_3 = (float*)(ptrPtrs[3] + wPos * 4);

		float* ptr_4 = (float*)(ptrPtrs[4] + wPos * 4);

		int* ptr_5 = (int*)(ptrPtrs[5] + wPos * 4);

		byte4* ptr_6 = (byte4*)(ptrPtrs[6] + wPos * 4);

		vec3 gl_FragCoord = vec3(0, h, 0);
		for (int w = 0; w < Width; ++w, ++ptr_0, ++ptr_1, ++ptr_2, ++ptr_3, ++ptr_4, ++ptr_5, ++ptr_6, ++gl_FragCoord.x){
			shaderMethod(ptr_0, ptr_1, ptr_2, ptr_3, ptr_4, ptr_5, ptr_6, uniform_0, uniform_1, uniform_2, uniform_3, uniform_4, uniform_5, uniform_6, uniform_7, uniform_8, uniform_9, uniform_10, gl_FragCoord);
		}
	}
}
