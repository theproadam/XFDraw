//Autogenerated by XFDraw shader parser
#include "xfcore.h"

#include <stdio.h>

#include "xfconfig.cpp"

inline vec3 rotateZAxis(vec3 input, vec2 rot);
inline float clamp01(float val);
inline float smoothstep(float edge0, float edge1, float x);


inline vec3 rotateZAxis(vec3 input, vec2 rot){
	return vec3(input.x * rot.x - input.y * rot.y, input.x * rot.y + input.y * rot.x, input.z);
	
}
inline float clamp01(float val){
	if (val > 1.0f) return 1.0f;
	else if (val < 0.0f) return 0.0f;
	else return val;
	
}
inline float smoothstep(float edge0, float edge1, float x){
	float t = clamp01((x - edge0) / (edge1 - edge0));
	return t * t * (3.0 - 2.0 * t);
	
}

inline void shaderMethod(vec3* frag_pos, vec3* normal, float* ssao_buffer, vec3 cameraPos, mat3 cameraRot, GLMatrix cameraProj, float kernel_radius, int kernel_size, sampler1D kernel, sampler2D depth, float bias, float ssao_power, int FrameCount, sampler2D ssao_noise, vec3 gl_FragCoord){
	vec3 camSpace = cameraRot * ((*frag_pos) - cameraPos);
	float occlusion = 0.0f;
	for (int i = 0;
	 i < kernel_size;
	 i++){
	vec3 pos = texture<vec3>(kernel, i);
	vec2 randomness = texture<vec2>(ssao_noise, vec2(gl_FragCoord));
	pos = rotateZAxis(pos, randomness);
	vec3 samplePos = cameraProj * (camSpace + pos * kernel_radius);
	float sampleDepth = cameraProj.farZ - texture<float>(depth, vec2(samplePos));
	float rangeCheck = 1.0f;
	if (abs(camSpace.z - sampleDepth) > 10.0f)rangeCheck = 0.0f;
	if (sampleDepth <= samplePos.z - bias){
	occlusion += 1.0f * rangeCheck;
	}
	}
	occlusion /= kernel_size;
	occlusion *= ssao_power;
	if (occlusion > 1.0f){
	occlusion = 1.0f;
	}
	if (occlusion < 0.0f){
	occlusion = 0;
	}
	(*ssao_buffer) = occlusion;
	
}
extern "C" __declspec(dllexport) void ShaderCallFunction(long Width, long Height, unsigned char** ptrPtrs, void* UniformPointer){
	vec3 uniform_0;
	fcpy((char*)(&uniform_0), (char*)UniformPointer + 0, 12);
	mat3 uniform_1;
	fcpy((char*)(&uniform_1), (char*)UniformPointer + 12, 36);
	GLMatrix uniform_2;
	fcpy((char*)(&uniform_2), (char*)UniformPointer + 48, 56);
	float uniform_3;
	fcpy((char*)(&uniform_3), (char*)UniformPointer + 104, 4);
	int uniform_4;
	fcpy((char*)(&uniform_4), (char*)UniformPointer + 108, 4);
	sampler1D uniform_5;
	fcpy((char*)(&uniform_5), (char*)UniformPointer + 112, 12);
	sampler2D uniform_6;
	fcpy((char*)(&uniform_6), (char*)UniformPointer + 124, 28);
	float uniform_7;
	fcpy((char*)(&uniform_7), (char*)UniformPointer + 152, 4);
	float uniform_8;
	fcpy((char*)(&uniform_8), (char*)UniformPointer + 156, 4);
	int uniform_9;
	fcpy((char*)(&uniform_9), (char*)UniformPointer + 160, 4);
	sampler2D uniform_10;
	fcpy((char*)(&uniform_10), (char*)UniformPointer + 164, 28);

#pragma omp parallel for
	for (int h = 0; h < Height; ++h){
		int wPos = Width * h;
		vec3* ptr_0 = (vec3*)(ptrPtrs[0] + wPos * 12);

		vec3* ptr_1 = (vec3*)(ptrPtrs[1] + wPos * 12);

		float* ptr_2 = (float*)(ptrPtrs[2] + wPos * 4);

		vec3 gl_FragCoord = vec3(0, h, 0);
		for (int w = 0; w < Width; ++w, ++ptr_0, ++ptr_1, ++ptr_2, ++gl_FragCoord.x){
			shaderMethod(ptr_0, ptr_1, ptr_2, uniform_0, uniform_1, uniform_2, uniform_3, uniform_4, uniform_5, uniform_6, uniform_7, uniform_8, uniform_9, uniform_10, gl_FragCoord);
		}
	}
}
